{"ast":null,"code":"async = require('async');\n\ntry {\n  var fs = require('fs');\n} catch (e) {\n  var fs = false;\n}\n/**\n * Gets the list of profanity words from the csv file\n * @function\n * @param {function(Array)} callback The function to pass profanity to.\n * @param {String} file (optional) The location of a csv file containing your list of profanity.\n */\n\n\nfunction loadCSV(callback, file) {\n  file = typeof file == 'string' ? file : __dirname + '/data/profanity.csv';\n\n  if (fs) {\n    if (typeof callback != 'function') throw new Error('isProfanity Error: Valid callback not given...');\n    fs.readFile(file, 'utf8', function (err, data) {\n      if (err) {\n        throw err;\n      } else {\n        callback(data.split(','));\n      }\n    });\n  } else {\n    //browser version\n    if (file.includes('exceptions')) {\n      e = require(__dirname + '/data/exceptions.js');\n      callback(e.t.split(','));\n    } else {\n      e = require(__dirname + '/data/profanity.js');\n      callback(e.t.split(','));\n    }\n  }\n}\n/**\n * Stores a word and it's current rating\n * @class\n * @param {String} word The word as a string\n * @param {Number} rating The Levenshtein distance provided by wangerFischer\n * @param {String} closeWord The word tested against\n */\n\n\nfunction Word(word, rating, closeWord) {\n  this.word = String(word) || '';\n  this.sureness = 1 - Number(rating) / this.word.length || 0;\n  this.closestTo = String(closeWord);\n}\n/**\n * Perform the Wagner-Fischer algorithm on the 2 inputs\n * ( https://en.wikipedia.org/wiki/Wagner%E2%80%93Fischer_algorithm )\n * @function\n * @param {String} str1 The first string to compare \n * @param {String} str2 The Second string to compare\n */\n\n\nfunction wagnerFischer(str1, str2) {\n  if (typeof str1 != 'string' || typeof str2 != 'string') throw new Error('isProfanity Error: Both str1 and str2 must both be strings...');\n  var dist = [];\n\n  for (var i = 0; i < str1.length + 1; ++i) dist[i] = [i];\n\n  for (var i = 0; i < str2.length + 1; ++i) dist[0][i] = i;\n\n  for (var t = 1; t < str2.length + 1; ++t) for (var i = 1; i < str1.length + 1; ++i) dist[i][t] = str1[i - 1] === str2[t - 1] ? dist[i - 1][t - 1] : Math.min.apply(Math, [dist[i - 1][t] + 1, dist[i][t - 1] + 1, dist[i - 1][t - 1] + 1]);\n\n  return dist[str1.length][str2.length];\n}\n/**\n * Passes a boolian to a callback saying whether a string contains profanity or not.\n * @function\n * @param {String} string The string to check for profanity.\n * @param {function(boolian)} callback The function to pass answer to.\n * @param {String} customProfanity (optional) The location of a csv file containing your list of profanity.\n * @param {String} customExceptions (optional) the location of a csv file containing exceptions that should not be blocked.\n * @param {float} sensitivity (optional) (requires custom exceptions list) How sensitive to be to changes. Must be between 0 and 1 (defaults to 0.67)\n */\n\n\nfunction isProfanity(string, callback, customProfanity, customExceptions, sensitivity) {\n  var minSure = sensitivity && sensitivity >= 0 && sensitivity <= 1 ? 1 - sensitivity : 0.32;\n  minSure = minSure < 0.32 ? customExceptions ? minSure : 0.32 : minSure;\n  customExceptions = customExceptions && fs ? customExceptions : __dirname + '/data/exceptions.csv';\n  if (typeof string != 'string') throw new Error('isProfanity Error: The var \\'string\\' is not a String...');\n  if (typeof callback != 'function') throw new Error('isProfanity Error: Valid callback not given...');\n  var containsASwear = false;\n  var blockedWords = new Array();\n  loadCSV(function (swears) {\n    loadCSV(function (exceptions) {\n      strings = string.split(' ');\n      async.each(strings, function (word, callback) {\n        word = word.replace(/\\b[-.,()&$#:!\\[\\]{}\"']+\\B|\\B[-.,()&$#:!\\[\\]{}\"']+\\b/g, \"\");\n        var WorstSwear = new Word();\n        var mostlikelyexception = new Word();\n        var foundExeption = exceptions.includes(word.toLowerCase());\n        async.each(swears, function (swear, callback) {\n          x = wagnerFischer(swear.toLowerCase(), word.toLowerCase());\n\n          if (new Word(word, x).sureness > WorstSwear.sureness) {\n            WorstSwear = new Word(word, x, swear);\n          }\n\n          callback();\n        }, function (err) {\n          if (!foundExeption && WorstSwear.sureness > minSure) {\n            blockedWords.push(WorstSwear);\n            containsASwear = true;\n          }\n        });\n        callback();\n      }, function (err) {\n        callback(containsASwear, blockedWords);\n      });\n    }, customExceptions);\n  }, customProfanity);\n}\n\nmodule.exports = isProfanity;","map":{"version":3,"sources":["/Users/rileycroucher/repos/UWTSD/reactcpa/client/node_modules/isprofanity/isProfanity.js"],"names":["async","require","fs","e","loadCSV","callback","file","__dirname","Error","readFile","err","data","split","includes","t","Word","word","rating","closeWord","String","sureness","Number","length","closestTo","wagnerFischer","str1","str2","dist","i","Math","min","apply","isProfanity","string","customProfanity","customExceptions","sensitivity","minSure","containsASwear","blockedWords","Array","swears","exceptions","strings","each","replace","WorstSwear","mostlikelyexception","foundExeption","toLowerCase","swear","x","push","module","exports"],"mappings":"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","sourcesContent":["async = require('async');\ntry {\n    var fs = require('fs')\n}catch(e){\n    var fs = false;\n}\n\n/**\n * Gets the list of profanity words from the csv file\n * @function\n * @param {function(Array)} callback The function to pass profanity to.\n * @param {String} file (optional) The location of a csv file containing your list of profanity.\n */\nfunction loadCSV(callback,file){\n    file = typeof(file) == 'string' ? file : __dirname+'/data/profanity.csv';\n    if(fs){\n        if(typeof(callback) != 'function') throw new Error('isProfanity Error: Valid callback not given...');\n        fs.readFile(file, 'utf8', function (err,data) {\n            if (err) {\n                throw err;\n            }else{\n                callback(data.split(','));\n            }\n        });\n    }else{//browser version\n        if(file.includes('exceptions')){\n            e = require(__dirname+'/data/exceptions.js');\n            callback(e.t.split(','));\n        }else{\n            e = require(__dirname+'/data/profanity.js');\n            callback(e.t.split(','));\n        }\n    }\n}\n/**\n * Stores a word and it's current rating\n * @class\n * @param {String} word The word as a string\n * @param {Number} rating The Levenshtein distance provided by wangerFischer\n * @param {String} closeWord The word tested against\n */\nfunction Word(word,rating,closeWord){\n    this.word = String(word) || '';\n    this.sureness = 1 - Number(rating)/this.word.length || 0;\n    this.closestTo = String(closeWord)\n}\n/**\n * Perform the Wagner-Fischer algorithm on the 2 inputs\n * ( https://en.wikipedia.org/wiki/Wagner%E2%80%93Fischer_algorithm )\n * @function\n * @param {String} str1 The first string to compare \n * @param {String} str2 The Second string to compare\n */\nfunction wagnerFischer(str1,str2){\n    if(typeof(str1) != 'string' || typeof(str2) != 'string') throw new Error('isProfanity Error: Both str1 and str2 must both be strings...');\n    var dist = [];\n    for(var i = 0; i < str1.length+1; ++i)\n        dist[i] = [i];\n    for(var i = 0; i < str2.length+1; ++i)\n        dist[0][i] = i\n    for (var t = 1; t < str2.length+1; ++t)\n        for (var i = 1; i < str1.length+1; ++i)\n            dist[i][t] = str1[i - 1] === str2[t - 1] ? dist[i-1][t-1] : \n                Math.min.apply(Math, [dist[i-1] [t]+1,dist[i] [t-1]+1,dist[i-1] [t-1]+1\n                ]);\n    return dist[str1.length][str2.length];\n}\n\n/**\n * Passes a boolian to a callback saying whether a string contains profanity or not.\n * @function\n * @param {String} string The string to check for profanity.\n * @param {function(boolian)} callback The function to pass answer to.\n * @param {String} customProfanity (optional) The location of a csv file containing your list of profanity.\n * @param {String} customExceptions (optional) the location of a csv file containing exceptions that should not be blocked.\n * @param {float} sensitivity (optional) (requires custom exceptions list) How sensitive to be to changes. Must be between 0 and 1 (defaults to 0.67)\n */\n\nfunction isProfanity(string,callback,customProfanity,customExceptions,sensitivity){\n    var minSure = sensitivity && sensitivity >= 0 && sensitivity <= 1 ? 1-sensitivity : 0.32;\n    minSure = minSure < 0.32 ? customExceptions ? minSure : 0.32 : minSure;\n    customExceptions = customExceptions && fs ? customExceptions : __dirname+'/data/exceptions.csv';\n    if(typeof(string) != 'string') throw new Error('isProfanity Error: The var \\'string\\' is not a String...');\n    if(typeof(callback) != 'function') throw new Error('isProfanity Error: Valid callback not given...');\n    var containsASwear = false;\n    var blockedWords = new Array();\n    loadCSV(function(swears){\n        loadCSV(function(exceptions){\n            strings = string.split(' ');\n            async.each(strings,function(word,callback) {\n                word = word.replace(/\\b[-.,()&$#:!\\[\\]{}\"']+\\B|\\B[-.,()&$#:!\\[\\]{}\"']+\\b/g, \"\");\n                var WorstSwear = new Word();\n                var mostlikelyexception = new Word();\n                var foundExeption = exceptions.includes(word.toLowerCase());\n                async.each(swears,function(swear,callback){\n                    x = wagnerFischer(swear.toLowerCase(),word.toLowerCase());\n                    if(new Word(word,x).sureness > WorstSwear.sureness){\n                        WorstSwear = new Word(word,x,swear);\n                    }\n                    callback();\n                }, function(err) {\n                    if(!foundExeption && WorstSwear.sureness > minSure){\n                        blockedWords.push(WorstSwear);\n                        containsASwear = true;\n                    }\n                });\n                callback();\n            }, function(err){\n                callback(containsASwear,blockedWords);\n            });\n        },customExceptions);\n    },customProfanity);\n}\n\nmodule.exports = isProfanity;"]},"metadata":{},"sourceType":"script"}